function B = simulate_flagella_produces_repressor(ktxn, kdr, ktln, kdp, krepressor, kdrepressor, K, A, D, maxcount)%  simulates a model in which a repressive signal is produced by the%  flagellum, at a rate proportional to flagellar length% parameters:%     alpha ktxn/kdr%     beta   ktln/kdp% gamma  (kR/kdR)/K'  relates to repressor activity%   K is K' in the model% A,D constants from balance point model%   %     maxcount how many iteratios to run the simulation% example call that gives a plot reasonably similar to actual data - this% is what was used for the figure in the paper% simulate_flagella_produces_repressor(1, 0.05, 1, 0.05, 5, 1, 2, 2, 1, 1500000);tstep = 0.0001; alpha = ktxn/kdr beta  = ktln/kdpgamma = (krepressor/kdrepressor)/K  theta = alpha*beta;maxgrowth = 0.5;   % maximum allowed growth rate for L to avoid blowing up when L near zerolss = (-1+sqrt(1+4*gamma*theta*A/D))/(2*gamma)rss = K*gamma*lssmss = alpha*(1/(1 + gamma*lss))pss = 2*lss + beta*mssmval = mss; % preshock message levellval = lss;  % preshock lengthpval = pss; % preshock protein levelrval = rss; % preshock repressor levelcyxmval = mss; % values for cycloheximide experimentcyxlval = lss;cyxpval = pss;cyxrval = rss;currstate=zeros(maxcount,6);  % will hold m, l, p normalized to ss valuesoutput_states = zeros(1+maxcount/100,6);new_output = zeros(1+maxcount/100,4);new_output2 = zeros(1+maxcount/100,2);new_output3 = zeros(1+maxcount/100,2);min=100000;max=0;maxres = 0;maxrestime = 0;openmin = 1000;outcount = 1;        for icount=1:maxcount           currstate(icount,1)=mval/mss;   currstate(icount,2)=lval/lss;   currstate(icount,3)=pval/pss;   currstate(icount,4)=cyxmval/mss;   currstate(icount,5)=cyxlval/lss;   currstate(icount,6)=cyxpval/pss;      if mod(icount,100)==0       outcount = outcount + 1;       output_states(outcount,1) = mval/mss;       output_states(outcount,2) = lval/lss;       output_states(outcount,3) = pval/pss;       output_states(outcount,4) = cyxmval/mss;       output_states(outcount,5) = cyxlval/lss;       output_states(outcount,6) = cyxpval/pss;   end      if icount==1       lval = 0.1; % pop off the flagella leaving a tiny stump (to avoid divide by zero)       pval = pval - 2*(lss-0.1); % loss of precursor       cyxlval = lval;       cyxpval = pval;       output_states(1,1) = mval/mss; % store post-shock value       output_states(1,2) = lval/lss;       output_states(1,3) = pval/pss;       output_states(1,4) = cyxmval/mss;       output_states(1,5) = cyxlval/lss;       output_states(1,6) = cyxpval/pss;   end   dmval = (ktxn)*(K/(K+rval)) - kdr*mval;      dlval = A*(pval - 2*lval)/lval - D;            if dlval > maxgrowth   % limit extreme growth when flagellum is very short to prevent discontinuity       dlval = maxgrowth;   end      dpval = ktln*mval - kdp*(pval - 2*lval); % only the cytoplasmic pool can be degraded      drval = krepressor*lval - kdrepressor*rval;         dcyxmval = (ktxn)*(K/(K+cyxrval)) - kdr*cyxmval;         dcyxlval = A*(cyxpval - 2*cyxlval)/cyxlval - D;      if dcyxlval > maxgrowth       dcyxlval = maxgrowth;   end         dcyxpval = -kdp*(cyxpval - 2*cyxlval); % only the cytoplasmic pool can be degraded      dcyxrval = krepressor*cyxlval - kdrepressor*cyxrval;                        mval = mval + tstep*dmval;   lval = lval + tstep*dlval;   pval = pval + tstep*dpval;   rval = rval + tstep*drval;   cyxmval = cyxmval + tstep*dcyxmval;   cyxlval = cyxlval + tstep*dcyxlval;   cyxpval = cyxpval + tstep*dcyxpval;   cyxrval = cyxrval + tstep*dcyxrval;         if mval <= 0        mval = 0.0001;   end   if lval <= 0        lval = 0.0001;   end   if pval <= 0        pval = 0.0001;   end   if rval <= 0        rval = 0.0001;   end   if cyxmval <= 0        cyxmval = 0.0001;   end   if cyxlval <= 0        cyxlval = 0.0001;   end   if cyxpval <= 0        cyxpval = 0.0001;   end   if cyxrval <= 0        cyxrval = 0.0001;   end      endlen_array = output_states(:,2);msg_array = output_states(:,1);% compute maximum NORMALIZED rna and length for plotting% note that these maxima are normalized by the steady state values% so for length, we expect maximum length should be 1 since it approaches% the steady state from below.  but for RNA the maximum should be more than% 1 since the system overshoots the steady state value in making a pulsemax_entry = 0;for i=1:(1+maxcount/100)    if len_array(i) > max_entry        max_entry = len_array(i);    endendmaximum_length = max_entrymax_entry = 0;for i=1:(1+maxcount/100)    if msg_array(i) > max_entry        max_entry = msg_array(i);    endendmaximum_msg = max_entry%max_msg = max(output_states(:,1))for i=1:(1+maxcount/100)    new_output(i,1) = output_states(i,1)/maximum_msg;    new_output(i,2) = output_states(i,2)/maximum_length;    new_output(i,3) = output_states(i,4)/maximum_msg;    new_output(i,4) = output_states(i,5)/maximum_length;endplot(new_output);  % all datafigure;for i=1:(1+maxcount/100)    new_output2(i,1) = output_states(i,1)/maximum_msg;    new_output2(i,2) = output_states(i,2)/maximum_length;    endplot(new_output2);  % mRNA and length for no-cyx experimentfigure;for i=1:(1+maxcount/100)    new_output3(i,1) = output_states(i,1)/maximum_msg;    new_output3(i,2) = output_states(i,4)/maximum_msg; endplot(new_output3);  % mRNA and length for cyx experimentB = new_output;