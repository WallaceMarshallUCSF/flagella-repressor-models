function B = simulate_flagella_sequesters_repressor(ktxn, kdr, ktln, kdp, krepressor, kdrepressor, K, A, D, maxcount)%  modified from simulates_flagella_produces_repressor to model the case in%  which a repressor is synthesized in the cell body and becomes%  transported into flagella as they assemble% parameters:%     alpha ktxn/kdr%     beta   ktln/kdp% gamma  (kR/kdR)/K'  relates to repressor activity%   K is K' in the model% A,D constants from balance point model% note that in this model, K is not the same as in the other model becuase% it already incorporates the proporitnoality constant F%   %     maxcount how many iteratios to run the simulation% example call that gives a plot reasonably similar to actual data% simulate_flagella_sequesters_repressor(0.05, 0.05, 1, 0.05, 5, 1, 1.0, 4, 2, 1500000);tstep = 0.0001; alpha = ktxn/kdr beta  = ktln/kdpgamma = (krepressor/kdrepressor)/K  phi = K*alpha*betatheta = alpha*beta;maxgrowth = 0.5;   % maximum allowed growth rate for L to avoid blowing up when L near zeroyss = (-K + sqrt(K^2 + 4*phi) )/2mss = alpha*(K/(K + yss))lss = A*yss/D%rss = K*gamma*lss  % in this model, r is not explicitly represented%pss = 2*lss + beta*mss   % p is not explicitly represented in this model%eithermval = mss; % preshock message levellval = lss;  % preshock lengthyval = yss; % preshock cytoplasmic protein level proportional to repressorcyxmval = mss; % values for cycloheximide experimentcyxlval = lss;cyxyval = yss;currstate=zeros(maxcount,6);  % will hold m, l, p normalized to ss valuesoutput_states = zeros(1+maxcount/100,6);new_output = zeros(1+maxcount/100,4);new_output2 = zeros(1+maxcount/100,2);new_output3 = zeros(1+maxcount/100,2);outcount = 1;        for icount=1:maxcount           currstate(icount,1)=mval/mss;   currstate(icount,2)=lval/lss;   currstate(icount,3)=yval/yss;   currstate(icount,4)=cyxmval/mss;   currstate(icount,5)=cyxlval/lss;   currstate(icount,6)=cyxyval/yss;      if mod(icount,100)==0       outcount = outcount + 1;       output_states(outcount,1) = mval/mss;       output_states(outcount,2) = lval/lss;       output_states(outcount,3) = yval/yss;       output_states(outcount,4) = cyxmval/mss;       output_states(outcount,5) = cyxlval/lss;       output_states(outcount,6) = cyxyval/yss;   end      if icount==1       lval = 0.1; % pop off the flagella leaving a tiny stump (to avoid divide by zero)       yval = yval - 2*(lss-0.1); % loss of precursor       cyxlval = lval;       cyxyval = yval;       output_states(1,1) = mval/mss; % store post-shock value       output_states(1,2) = lval/lss;       output_states(1,3) = yval/yss;       output_states(1,4) = cyxmval/mss;       output_states(1,5) = cyxlval/lss;       output_states(1,6) = cyxyval/yss;   end   dmval = (ktxn)*(K/(K+yval)) - kdr*mval;         dlval = A*yval/lval - D;      dyval = ktln*mval + 2*D - yval*(kdp + 2*A/lval); % last term is IFT-mediated pumping repressor into flagellum            if dlval > maxgrowth   % limit extreme growth when flagellum is very short to prevent discontinuity       dlval = maxgrowth;   end            %drval = krepressor*lval - kdrepressor*rval;  % in this model r is   %derived from P and L         dcyxmval = (ktxn)*(K/(K+cyxyval)) - kdr*cyxmval;         dcyxlval = A*cyxyval/cyxlval - D;      if dcyxlval > maxgrowth       dcyxlval = maxgrowth;   end            dcyxyval = 2*D - cyxyval*(kdp + 2*A/cyxlval);                              mval = mval + tstep*dmval;   lval = lval + tstep*dlval;   yval = yval + tstep*dyval;      cyxmval = cyxmval + tstep*dcyxmval;   cyxlval = cyxlval + tstep*dcyxlval;   cyxyval = cyxyval + tstep*dcyxyval;            if mval <= 0        mval = 0.0001;   end   if lval <= 0        lval = 0.0001;   end   if yval <= 0        yval = 0.0001;   end     if cyxmval <= 0        cyxmval = 0.0001;   end   if cyxlval <= 0        cyxlval = 0.0001;   end   if cyxyval <= 0        cyxyval = 0.0001;   end         endlen_array = output_states(:,2);msg_array = output_states(:,1);max_entry = 0;for i=1:(1+maxcount/100)    if len_array(i) > max_entry        max_entry = len_array(i);    endendmaximum_length = max_entrymax_entry = 0;for i=1:(1+maxcount/100)    if msg_array(i) > max_entry        max_entry = msg_array(i);    endendmaximum_msg = max_entry%max_msg = max(output_states(:,1))for i=1:(1+maxcount/100)    new_output(i,1) = output_states(i,1)/maximum_msg;    new_output(i,2) = output_states(i,2)/maximum_length;    new_output(i,3) = output_states(i,4)/maximum_msg;    new_output(i,4) = output_states(i,5)/maximum_length;endplot(new_output);  % all datafigure;for i=1:(1+maxcount/100)    new_output2(i,1) = output_states(i,1)/maximum_msg;    new_output2(i,2) = output_states(i,2)/maximum_length;    endplot(new_output2);  % mRNA and length for no-cyx experimentfigure;for i=1:(1+maxcount/100)    new_output3(i,1) = output_states(i,1)/maximum_msg;    new_output3(i,2) = output_states(i,4)/maximum_msg; endplot(new_output3);  % mRNA and length for cyx experimentfinal_length = output_states((maxcount/100), 2)B = new_output;